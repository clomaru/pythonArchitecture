# #########
# #
# # concurrent.futures
# #
# #########
# import concurrent.futures
# import time
#
# def Calc(number):
#     #何か重い処理
#     time.sleep(1)
#
# numbers=[14,60,900,30,30]
# start = time.time()
#
# #multi process
# '''
# 並列処理させる
# max_workersは同時並行に処理するプロセスの数
# このモジュールはマルチプロセスで処理をしたあと、それぞれのプロセスのデータをプロセス間通信で、データのやり取りをする
# なので、処理のオーバーヘッドが多く、あまりワーカーを増やしすぎても処理性能はあまり上がらないことも多い
# '''
# pool=concurrent.futures.ProcessPoolExecutor(max_workers=2)
# result=list(pool.map(Calc,numbers))
#
# # single process
# # result=list(map(Calc,numbers))
#
# end = time.time()
# print('%.3f' %(end-start))

# #########
# #
# # Queue
# #
# #########
# # マルチプロセスで別々に処理し、処理とその次の処理にプロセス間でデータを送ることができる
# # effective python p.132
# import time
# import multiprocessing
#
# q12 = multiprocessing.Queue()
# q23 = multiprocessing.Queue()
#
# def Calc1(number):
#     time.sleep(1)
#     q12.put(number) # putでデータを追加
#
# def Calc2(number):
#     data=q12.get() # getでデータを受信
#     time.sleep(2)
#     q23.put(data)
#
# def Calc3(number):
#     data=q23.get()
#     time.sleep(1)
#     print("result"+str(data))
#
#
# if __name__ == '__main__':
#     start = time.time()
#     for i in range(10):
#         p1 = multiprocessing.Process(target=Calc1, args=(i,))
#         p1.start()
#         p2 = multiprocessing.Process(target=Calc2, args=(1,))
#         p2.start()
#         p3 = multiprocessing.Process(target=Calc3, args=(1,))
#         p3.start()
#
#     p1.join()
#     p2.join()
#     p3.join()
#     end = time.time()
#     print('%.3f' %(end-start))
